namespace _02.Operator
{
    // 연산자(Operator)

    // 프로그래밍 언어에서는 일반적인 수학 연산과 유사한 연산자들이 지원됨
    // C#에서는 여러 연산자를 제공하며 기본 연산을 수행할 수 있음

    // 게임을 만들 때 다양하게 변화하는 요소에 따라 연산을 해야하는 경우가 많음
    // 해당 연산을 지원? -> 상황에 따라 데이터의 처리등을 계산해 줄 수 있다

    class Program
    {
        static void Main(string[] args)
        {
            bool b = false;
            int i = 0;
            float f = 0.0f;

            // 산술 연산자

            // 이진 연산자
            i = 2 + 3; // +(더하기)
            i = 3 - 1; // -(빼기)
            i = 3 * 3; // *(곱하기)
            i = 5 / 2; // /(나누기) ※주의!! 정수 나눗셈은 결과를 정수로 계산되므로 소수점 버려짐
            // Console.WriteLine(i); // -> 2로 출력됨
            // f = 5.0f / 2.0f;
            // Console.WriteLine(f); //-> 2.5 출력
            i = 13 % 3; // %(나머지)

            // 단항 연산자
            i = +3;     // + 단항연산자(양수) i = 3과 동일. 의미 없으며 값을 그대로 둠
            i = -3;     // - 단항연산자(음수) 값을 마이너스로 변환 -> 2의 보수로 만든다.
            ++i;        // ++ 전위증가연산자 기존값에 1더하기 / i = i + 1과 동일 
            i++;        // ++ 후위증가연산자 : 값을 1 증가
            --i;        // -- 전위감소연산자 기존값에 1빼기 / i = i - 1과 동일
            i--;        // -- 후위감소연산자 : 값을 1 감소

            // 전위연산자와 후위연산자

            // 전위연산자 : 더하고 값 불러오기
            // 후위연산자 : 값 불러오고 더하기
            i = 0;
            Console.WriteLine(i);   // output : 0
            Console.WriteLine(++i); // output : 1
            Console.WriteLine(i);   // output : 1
            i = 0;
            Console.WriteLine(i);   // output : 0
            Console.WriteLine(i++); // output : 0 -> output은 0이나 i의 값은 1로 변경 -> 후위 연산자는 값을 불러오고 변경
            Console.WriteLine(i);   // output : 1

            // 대입연산자

            i = 10; // = 대입연산자 : 오른쪽 값을 왼쪽 변수에 대입
            // i = 10; -> (=) 기호가 대입 연산자이며 오른쪽의 데이터를 왼쪽의 변수에 대입하겠다라는 의미

            i = i + 10;
            i += 10;
            // 복합 대입 연산자
            // 이진 연산자(op)가 있을 경우 
            // x = x op y; => x op= y; 로 사용가능.

            int hp = 100;

            hp += 10;   // hp = hp + 10;
            hp -= 5;    // hp = hp - 5;

            // 비교 연산자

            // 수치끼리 비교해야 할 케이스가 많음 ex) 내 경험치가 목표치보다 크다면 ..
            // 비교 연산자의 결과는 true, false로 나옴 ex) 3 < 1 -> false, 3 > 1 -> true
            // bool 변수에 해당 결과를 저장할 수 있음

            b = 3 > 1;  // > : 왼쪽 데이터가 더 클 경우 true, 아니면 false
            b = 3 < 1;  // < : 왼쪽 데이터가 더 작을 경우 true, 아니면 false
            b = 3 >= 1; // >= : 왼쪽 데이터가 더 크거나 같은 경우 true, 아니면 false
            b = 3 <= 1; // <= : 왼쪽 데이터가 더 작거나 같은 경우 true, 아니면 false
            b = 3 == 1; // == : 두 데이터가 같은 경우 true, 아니면 false
            b = 3 != 1; // != : 두 데이터가 다른 경우 true, 아니면 false

            // 논리 연산자

            // 스킬 사용? -> 보통은 쿨타임도 전부 기다렸으면서 그리고 마나는 있는 상태 두 가지를 만족하여야 함 => 두 조건을 동시에 만족해야 함.
            // 마피아게임 승리 조건? -> 마피아를 전부 투표로 잡거나 또는 미션 전부 클리어 => 한 조건을 만족시켜도 승리.
            // 두 가지 모두 논리를 통해 연산 진행 -> 논리 연산자

            float coolTime = 3.1f;
            int mp = 20;

            b = !true;          // !(Not)  : true -> false, false -> true 데이터를 논리 부정으로 변환
            b = true && false;  // &&(And) : 두 데이터 모두 true 일때 true, 아니면 false
            b = true || false;  // ||(Or)  : 둘 중 하나라도 true 일때 true, 아니면 false -> 둘 다 false이면 false

            // !true            -> false
            // !false           -> true
            // true && true     -> true
            // true && false    -> false
            // false && true    -> false
            // false && false   -> false
            // true || true     -> true
            // true || false    -> true
            // false || true    -> true
            // false || false   -> false

            // 조건부 논리 연산자 : 주의사항 -> 이용하는 경우도 있긴 함

            // 조건부 논리 Or 연산자 ||
            // 빠른 계산을 위해 true || x(논리자료형)의 경우 어떠한 논리자료형이 있어도
            // 결과는 항상 true이기 때문에 true || x 에서 x는 무시하게 됨

            i = 10;
            b = true || (i++ > 5); // 조금 특이한 예제??
            Console.WriteLine(i);  // i가 11으로 되어야 하지만 10으로 출력 -> true ||에서 뒤의 내용을 바로 생략해 버림
            // b = (i++ > 5) || true; -> 이 부분의 결과는 위의 결과와 다를 것

            // 조건부 논리 And 연산자 &&
            // 빠른 계산을 위해 false && x(논리자료형) 의 경우 어떠한 논리자료형이 있어도
            // 결과는 항상 false이기 때문에 false && x 에서 x는 무시하게 됨

            i = 10;
            b = false && (i++ > 5);
            Console.WriteLine(i); // 위의 이유와 동일

            // 비트 연산자

            // 컴퓨터는 기본적으로 0과 1로 이루어진 비트단위로 움직임
            // 컴퓨터에게 비트 단위로 연산을 요청하는 연산자 -> 비트 연산자가 일반 연산보다 매우 빠름

            i = 0b0011;     // 0b를 숫자 앞에 붙임으로 뒤의 수가 2진수가 됨
            i = 0x001F;     // 0x를 숫자 앞에 붙임으로 뒤의 수가 16진수가 됨

            // 단항 연산자
            i = ~0x1F;      // ~(비트 보수) : 데이터를 비트단위로 보수 연산 ex) 1001 -> 0110

            // 이진 연산자
            i = 0x11 & 0x83;    // 데이터를 비트단위로 And 연산 ex) 1001 & 1100 -> 1000
            i = 0x11 | 0x83;    // 데이터를 비트단위로 Or  연산 ex) 1001 | 1100 -> 1101

            // 비트 쉬프트 연산자

            // 비트 단위로 옮기기 ex) 0010 << 1 -> 0100, 0110 << 1 -> 1100 
            // 언제/왜 사용하는지? -> 1칸 이동한다?
            // ex) 10진수 1을 왼쪽으로 1칸 이동 -> 10, 2칸 이동 -> 100... 1칸 이동 시 x10
            // 컴퓨터는 곱하기 연산은 빠른편이지만 쉬프트 연산이 더 빠름(약 100배?)

            i = 0x10 << 2;  // << : 데이터를 비트 단위로 왼쪽으로 이동
            i = 0x11 >> 1;  // >> : 데이터를 비트 단위로 오른쪽으로 이동

            // 연산자 우선순위

            // 여러 연산자가 있는 식에서 우선 순위가 높은 연산자가 먼저 계산
            // ex) 2 + 2 * 2 => 6
            // 단항 > 곱하기 > 더하기 > 비교 > 논리(and > or) > 대입 -> 귀찮은건 괄호로 해결

            // 1. 기본 연산
            // 2. 단항 연산
            // 3. 곱하기 연산
            // 4. 더하기 연산
            // 5. 시프트 연산
            // 6. 비교 연산
            // 7. 같음 연산
            // 8. 논리 연산
            // 9. 대입 연산

        }
    }
}
