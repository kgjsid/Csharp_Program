namespace _01.Variable
{
    class Program
    {
        // 자료형

        // 자료(데이터)의 형태를 저장
        // 데이터가 메모리에 저장되는 형태와 처리되는 방식을 명시하는 역할
        // 0과 1만으로 구성된 컴퓨터에게 여러 형태의 자료를 저장하기 위함
        // 기본적인 컴퓨터의 저장단위는 byte(1byte = 8bit)

        // 컴퓨터는 0, 1 두 개의 처리밖에 할 수 없으므로 컴퓨터에게 자료의 형태를 지정해 준다고 생각
        // 1bit => 0, 1 두개의 표현 -> 컴퓨터는 이진수 체계로 계산
        // 0   1   2   3   4   5   6 
        // 0   1  01  11 100 101 110

        // 컴퓨터의 입장에서 1bit만 이용하기보다 1byte씩 움직이는 것이 안정적

        // 자료형의 종류

        // (이름)             (형태)            (크기)            (표현 범위)
        // bool(논리형)       논리자료형         1 byte            true(0이 아닌 수), false(0)

        // byte(정수형)       정수형             1 byte           0 ~ 255
        // short(정수형)      정수형             2 byte           -2^15 ~ 2^15 - 1 => -32,786 ~ 32,767
        // int(정수형)        정수형             4 byte           -2^31 ~ 2^31 - 1 => -21억 ~ 21억
        // uint(정수형)       정수형             4 byte           0 ~ 2^32 - 1     => 0 ~ 42억
        // long(정수형)       정수형             8 byte           -2^63 ~ 2^63 - 1 => -9경 ~ 9경

        // float(실수형)      부동소수점 실수형   4 byte           3.4e-38 ~ 3.4e+38   => 약 소수점 7자리
        // double(실수형)     부동소수점 실수형   8 byte           1.7e-308 ~ 1.7e+308 => 약 소수점 15자리

        // char              유니코드 문자형     2 byte           'a', 'b', '한', '글', ..(문자 하나)
        // string            유니코드 문자열       x              "accef", "감자", ... (여러 문자)

        // 컴퓨터는 기본적으로 0과 1을 사용하는 형식인데 어떻게 문자를 표현하느냐? -> 약속이 있음 => 아스키코드
        // 아스키코드는 일반적인 알파벳 기준(1byte로 표현가능) -> 한글, 일본어 등 다양한 언어를 표현하지 못함
        // => 유니코드(2byte)로 표현 가능

        // 변수(variable)

        // 데이터를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리(저장소/RAM) 공간
        // 데이터를 저장할 수 있는 메모리 공간을 의미하며, 저장된 값은 변경 가능
        // 자료형과 함께 변수 공간의 이름으로 만들 수 있음.

        static void Main(string[] args)
        {
            // 기본적으로 컴퓨터가 데이터를 0, 1로 구성
            // 하지만 일반적으로 사람들이 사용하는 데이터는 12323, "감자", 0.2, true/false, 등 다양한 형태를 저장함.
            // 데이터의 형태가 필요함. -> 자료형

            // 변수 선언 및 초기화
            // 자료형의 선언하고 빈칸 뒤에 변수이름을 작성하여 변수 선언
            // 선언한 변수에 값을 처음 할당하는 과정을 초기화라고 함
            // 변수 선언과 초기화 과정을 동시에 진행할 수 있음

            // 변수 주의사항
            // 이름이 동일한 변수는 만들 수 없음
            // 변수에 데이터를 넣을 때 반드시 자료형에 맞게 넣어줘야 함
            // 변수를 사용하기 전 반드시 초기화가 필요함 -> 초기화를 하지 않으면 에러
            // 변수에 용도에 알맞은 이름을 지어줄 것(level, exp, gold...) 

            int level;      // level이라는 정수형 변수(저장공간) 만들기
            char input;     // input이라는 문자형 저장공간 만들기
            float percent;  // percent이라는 실수형 저장공간 만들기
            string id;      // id라는 문자열 저장공간 만들기

            // level은 10의 데이터를 저장한다
            // =(대입연산자) -> 좌측에 변수를 배치하여 오른쪽의 값을 저장함
            level = 10; // 초기화(처음으로 데이터를 저장하는 것)

            // 변수명을 통하여 안의 데이터를 불러올 수 있다.
            Console.Write("당신의 레벨 : ");
            Console.WriteLine(level); // 10 출력

            level = 20; // 대입

            Console.Write("당신의 레벨 : ");
            Console.WriteLine(level); // 20으로 변경

            level = 30; // 대입

            Console.Write("당신의 레벨 : ");
            Console.WriteLine(level); // 30으로 변경

            // float형은 f를 붙여줌으로 double과 구분함
            percent = 1.23456f;

            // 두 개의 차이
            Console.WriteLine(percent); // 1.23456 출력
            Console.WriteLine("percent"); // percent 출력

            // 만약 중간에 변수를 넣고 싶다면?
            // "" 앞에 $표시와 함께 {}(중괄호)안에 변수명을 넣어줌
            Console.WriteLine($"percent에 저장한 값은 {percent}입니다.");
            Console.WriteLine("percent에 저장한 값은 {percent}입니다.");
            Console.WriteLine($"percent에 저장한 값은 {percent,10:F3}입니다."); // 소수점 아래 3자리 까지

            // 최대 경험치, 최대 인원수 등 바뀌지 않아야 하는 값은?
            // 한번 설정하고 바뀌지 않도록 설정이 필요 -> 상수

            // 상수(Constant)

            // 프로그램이 실행되는 동안 변경할 수 없는 데이터
            // 프로그램에서 값이 변경되기를 원하지 않는 데이터가 있을 경우 사용
            // 저장된 값은 프로그램 종료시까지 변경 불가능

            // 상수 선언 및 초기화 -> 반드시 초기화를 해야함
            // const를 앞에 붙여줌으로 변경할 수 없는 상수로 만들어 줌 -> 중간에 변경이 불가능
            const int MAXEXP = 100;
            const string GAMENAME = "ab";
            // const int MIN; -> 오류 -> 상수는 반드시 초기화가 필요함

            Console.WriteLine($"상수에 저장된 값은 {MAXEXP}입니다.");


            // 100개의 변수가 필요한 상황을 가정
            // int student1, student2, student3, ...., student100 -> 번거로움 -> 여러개의 저장소가 필요함 => 배열

            // 배열(Array)

            // 동일한 자료형의 요소들로 구성된 데이터 집합
            // 인덱스를 통하여 개개의 배열요소(Element)에 접근할 수 있음
            // 배열의 처음 요소의 인덱스는 0부터 시작함(0, 1, 2, 3,...)

            // 배열의 사용

            // 자료형 뒤에 [] 괄호를 추가하여 배열로 사용함을 선언
            // 배열의 이름 뒤 [] 괄호안에 숫자(인덱스)를 이용하여 각 칸을 이용할 수 있다

            int[] exam = new int[26];   // 26칸의 int 배열 만들기
            char[] grade;               // char 배열 만들기
            grade = new char[20];       // 해당 배열은 20칸

            // 배열의 초기화

            // {}안에 데이터를 ,를 기준으로 넣어주면 초기화 가능
            // 이 때의 배열의 크기는 초기화한 갯수만큼 배열의 크기가 자동으로 정해짐

            float[] farray = { 1.1f, 2.2f, 3.3f }; // 3칸의 float 배열 만들기

            exam[0] = 99; // 배열의 첫번째(요소 / element)
            exam[1] = 20; // 배열의 두번째(요소 / element)
            exam[2] = 60; // 배열의 세번째(요소 / element)

            Console.WriteLine(exam[2]); // 배열의 세번째 값 출력하기

            // 300칸의 배열을 생각. 271번의 배열은?? -> 의미를 찾기 어려우며 조금 더 나뉜 기준이 필요 => 다차원 배열

            // 다차원 배열

            // 다차원 배열의 선언은 자료형뒤에 []괄호를 추가하며, 추가하는 차원수만큼 ','를 추가
            int[,] matrix = new int[5, 10];     // 10개짜리 5개 => 50개 2차원 배열
            int[,,] cube = new int[3, 5, 20];   // 20개짜리 5개 3그룹 크기 => 300개 3차원 배열

            matrix[0, 2] = 20;  // 사용방법은 배열과 동일
            cube[2, 3, 5] = 10;

            int gold = 100;         // 정수 변수
            string name = "감자";   // 문자열 변수

            // gold = "감자"; 불가능 -> int형 안에 문자열 데이터를 넣을 수 없음 -> 자료'형변환'이 필요함
            // name = 100;

            // 형변환(Casting)

            // 데이터를 선언한 자료형에 맞는 형태로 변환하는 작업
            // 다른 자료형의 데이터를 저장하기 위해선 형변환 과정을 거쳐야하며,
            // 이 과정에서 보관할 수 없는 데이터는 버려짐

            // 명시적 형변환 - 수동
            // 변환할 데이터의 앞에 변환할 자료형을 괄호안에 넣어서 형변환 진행
            // 데이터의 손실이 있는 경우 반드시 사용해야 함
            int damage = (int)29.9f; // 29.9를 int로 변환하는 과정 중 보관할 수 없는 소수점은 버려짐

            // 묵시적 형변환 - 자동
            // 상대적으로 넣어야 할 변수의 자료형이 큰 경우(float값을 double에 넣기) 손실이 없어 자동으로 형변환
            double d1 = 123.345f;    // double이 float를 포함하는 더 큰 범위이니 자동형변환 가능
            double d2 = 1;           // int형이 float, double보다 작은 범위이니 자동형변환 가능
            float f1 = 1;

            // 문자 형변환
            // 문자를 숫자로 저장하고 숫자로 있어도 문자 형태로 보여주니 충분히 가능(아스키코드, 유니코드)
            char key = (char)65; // 아스키 코드값 65(a)를 문자로 변환시키니 가능함
            int value = (int)'a'; // 역도 충분히 가능

            // 문자열 형변환

            // int hp = (int)"100"; 불가능
            // 문자열은 단순형변환이 불가
            // 각 자료형의 Parse, TryParse를 이용하여 문자열에서 자료형으로 변환
            // 각 자료형에서 ToString을 이용하여 자료형에서 문자열로 변환

            int hp = int.Parse("100");          // 문자열 100을 정수로 변환
            float per = float.Parse("1.2");     // 문자열 1.2를 float로 변환
            int mp;

            string hundred = 100.ToString();    // 정수 100을 문자열 "100"으로 변환
            string s1 = 10.2f.ToString();       // 실수 10.2를 문자열 "10.2"로 변환 

            int.TryParse("100", out mp); // 변환을 시도하기 -> 혹여나 잘못된 변환이라면 실행하지 않음 -> 안전한 변환

        }
    }
}

